# 智能快递柜系统开发周报

## 项目背景

智能快递柜系统是一个基于Go语言和Kratos框架开发的现代化快递柜管理平台。通过智能化的网点管理，柜格管理、灵活的计费规则和便捷的用户
体验，为用户提供24小时自助存取服务。项目采用前后端分离架构，支持多端访问，具备完整的业务流程管理能力。

## 本周工作内容

### 1. 管理员登录功能开发

**工作效果：**
- 实现了安全可靠的管理员身份验证系统
- 支持手机号+验证码+密码
- 集成JWT Token认证，确保接口访问安全

**实现方式：**
```go
func (s *AdminService) AdminLogin(ctx context.Context, req *pb.AdminLoginReq) (*pb.AdminLoginRes, error) {
    // 1. 验证码校验（Redis缓存）
    get := s.data.Redis.Get(context.Background(), "sendSms"+req.Mobile+"admin_login")
    if get.Val() != req.SmsCode {
        return &pb.AdminLoginRes{Code: 500, Msg: "验证码错误"}, nil
    }
    
    // 2. 用户信息查询
    var admin data2.Admin
    err := s.data.DB.Debug().Where("mobile = ?", req.Mobile).Find(&admin).Error
    
    // 3. 密码验证
    if req.Password != admin.Password {
        return &pb.AdminLoginRes{Code: 500, Msg: "密码错误"}, nil
    }
    
    // 4. JWT Token生成
    claims := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "your_custom_claim": "your_custom_value",
        "id": "123",
    })
    signedString, err := claims.SignedString([]byte(s.server.Jwt.Authkey))
}
```

**难点与优化点：**
- **难点**：需要处理多种验证失败场景，确保系统安全性
- **优化点**：使用Redis缓存验证码，提高验证效率；JWT Token包含用户身份信息，减少数据库查询

### 2. 管理端网点管理功能

**工作效果：**
- 实现了完整的网点展示操作
- 支持网点列表查询和详细信息查看
- 提供网点状态管理和可用柜格数量统计

**实现方式：**
```go
func (s *AdminService) PointList(ctx context.Context, req *pb.PointListReq) (*pb.PointListRes, error) {
    // 1. Redis缓存查询
    key := fmt.Sprintf("ito-deposit/admin/PointList%s", "111")
    res, err := s.data.Redis.Get(context.Background(), key).Result()
    if res != "" {
        var data pb.PointListRes
        json.Unmarshal([]byte(res), &data)
        return &data, nil
    }
    
    // 2. 数据库查询
    var point []data2.LockerPoint
    err = s.data.DB.Debug().Find(&point).Error
    
    // 3. 数据转换和缓存
    var lists []*pb.PointList
    for _, l := range point {
        list := pb.PointList{
            Name: l.Name, Address: l.Address,
            AvailableLarge: int64(l.AvailableLarge),
            AvailableMedium: int64(l.AvailableMedium),
            AvailableSmall: int64(l.AvailableSmall),
            Id: int64(l.Id),
        }
        lists = append(lists, &list)
    }
    
    // 4. 设置缓存
    jsonList, _ := json.Marshal(res1)
    s.data.Redis.Set(context.Background(), key, jsonList, time.Minute*5)
}
```

**优化点：**
- **优化点**：使用Redis缓存减少数据库压力，缓存时间设置为5分钟；支持网点状态实时更新

### 3. 管理端收费规则套餐功能

**工作效果：**
- 实现了计费规则配置系统
- 支持多种计费模式（按小时、按天）
- 提供押金、预付款、免费时长等复杂计费参数配置

**实现方式：**
```go
func (s *AdminService) SetPriceRule(ctx context.Context, req *pb.SetPriceRuleReq) (*pb.SetPriceRuleRes, error) {
    // 1. 参数校验
    if req.NetworkId <= 0 {
        return nil, status.Error(codes.InvalidArgument, "网点ID必须大于0")
    }
    
    // 2. 开启事务
    tx := s.data.DB.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()
    
    // 3. 停用旧规则（软删除）
    tx.Model(&data2.LockerPricingRules{}).
        Where("network_id = ? AND status = 1", req.NetworkId).
        Update("status", 0)
    
    // 4. 创建新规则
    for _, rule := range req.Rules {
        newRule := &data2.LockerPricingRules{
            NetworkId: req.NetworkId,
            RuleName: rule.RuleName,
            FeeType: convertToFeeType(rule.FeeType),
            LockerType: convertToLockerType(rule.LockerType),
            FreeDuration: convertToDecimal(rule.FreeDuration),
            HourlyRate: convertToDecimal(rule.HourlyRate),
            DailyCap: convertToDecimal(rule.DailyCap),
            // ... 其他字段
        }
        tx.Create(newRule)
    }
    
    // 5. 提交事务
    tx.Commit()
}
```

**难点与优化点：**
- **难点**：需要处理复杂的计费规则逻辑和事务一致性
- **优化点**：使用数据库事务确保数据一致性；软删除机制保留历史数据；参数校验防止无效数据

### 4. gin-vue-admin管理端计费规则-订单管理

**工作效果：**
- 集成了gin-vue-admin框架，提供完整的管理后台界面
- 实现了计费规则展示界面
- 支持订单的管理

**实现方式：**
- 前端使用Vue.js构建管理界面
- 后端提供API接口
- 实现了JWT白名单机制，确保接口安全

**难点与优化点：**
- **难点**：前后端数据格式转换和状态同步
- **优化点**：使用JWT白名单机制，登录接口无需认证；统一的错误处理和响应格式

### 5. 管理员端图片上传MinIO功能

**工作效果：**
- 实现了安全的文件上传功能
- 支持图片格式验证和大小限制
- 集成MinIO对象存储，提供高可用文件服务

**实现方式：**
```go
func (s *AdminService) DownloadFile(ctx kratosHttp.Context) error {
    // 1. 获取上传文件
    _, file, err := req.FormFile("file")
    
    // 2. 格式验证
    ext := filepath.Ext(file.Filename)
    if ext != ".png" && ext != ".jpg" {
        return ctx.Result(500, map[string]interface{}{
            "code": 500, "message": "格式只能是png或者jpg",
        })
    }
    
    // 3. 大小验证
    if file.Size >= 200*1024*1024 {
        return ctx.Result(500, map[string]interface{}{
            "code": 500, "message": "大小不能超过200MB",
        })
    }
    
    // 4. 上传到MinIO
    url, err := UploadFile(file.Filename, file, s.conf)
}

func UploadFile(objectName string, fileHeader *multipart.FileHeader, c *conf.Data) (string, error) {
    // 1. 初始化MinIO客户端
    minioClient, err := minio1.New(c.Minio.Endpoint, &minio1.Options{
        Creds: credentials.NewStaticV4(c.Minio.AccessKeyId, c.Minio.AccessKeySecret, ""),
        Secure: c.Minio.UseSsl,
    })
    
    // 2. 构造对象名（按日期分类）
    objectName = fmt.Sprintf("%s/%s", time.Now().Format("2006-01-02"), objectName)
    
    // 3. 上传文件
    _, err = minioClient.PutObject(
        context.Background(),
        c.Minio.BucketName,
        objectName,
        src,
        fileHeader.Size,
        minio1.PutObjectOptions{ContentType: fileHeader.Header.Get("Content-Type")},
    )
    
    // 4. 返回访问地址
    return fmt.Sprintf("%s/%s/%s", c.Minio.Endpoint, c.Minio.BucketName, objectName), nil
}
```

**难点与优化点：**
- **难点**：需要处理文件上传的安全性和性能问题
- **优化点**：严格的格式和大小验证；按日期分类存储便于管理；MinIO提供高可用和扩展性

### 6. Redis缓存优化

**工作效果：**
- 对查询和详情接口进行了缓存优化
- 显著提升了系统响应速度
- 减少了数据库压力

**实现方式：**
```go
// 网点列表缓存
key := fmt.Sprintf("ito-deposit/admin/PointList%s", "111")
res, err := s.data.Redis.Get(context.Background(), key).Result()
if res != "" {
    var data pb.PointListRes
    json.Unmarshal([]byte(res), &data)
    return &data, nil
}
// 查询数据库并设置缓存
s.data.Redis.Set(context.Background(), key, jsonList, time.Minute*5)

// 计费规则缓存
key := fmt.Sprintf("ito-deposit/admin/GetPriceRule%s", req.NetworkId)
// 类似的缓存逻辑
```

**难点与优化点：**
- **难点**：缓存一致性和失效策略的设计
- **优化点**：设置合理的缓存时间（5分钟）；

### 7. uni-app上线

**工作效果：**
- 完成了uni-app的开发和部署
- 提供了完整的用户端管理端功能

**实现方式：**
- 使用uni-app框架开发
- 集成后端API接口
- 前后端对接接口
- http://8.155.62.49/

**难点与优化点：**
- **难点**：多平台兼容性和性能优化
- **优化点**：统一的API接口设计；响应式布局适配不同屏幕；本地缓存提升用户体验

## 技术亮点

1. **微服务架构**：基于Kratos框架，支持gRPC和HTTP双协议
2. **缓存优化**：Redis缓存策略显著提升系统性能
3. **安全机制**：JWT认证、参数验证、文件上传安全控制
4. **事务处理**：数据库事务确保数据一致性
5. **对象存储**：MinIO提供高可用文件存储服务
6. **跨平台支持**：uni-app实现多端统一开发
